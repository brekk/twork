import type { Maybe } from "Maybe"

import ByteArray from "ByteArray"
import Float from "Float"
import { always } from "Function"
import IO from "IO"
import Integer from "Integer"
import List from "List"
import Math from "Math"
import { Just, Nothing, fromMaybe } from "Maybe"
import String from "String"

import { log } from "@/Log"



alias DistanceConfig = {
  useDamerau :: Boolean,
  weights :: { delete :: Byte, insert :: Byte, substitute :: Byte },
}

DEFAULT_CONFIG = { useDamerau: true, weights: { delete: 1_b, insert: 1_b, substitute: 1_b } }


// distanceWithConfig :: DistanceConfig -> String -> String -> List (List (Maybe Float))
export distanceWithConfig = (config, a, b) => {
  lenX = String.length(a)
  lenY = String.length(b)
  return if (lenX == 0) {
    Integer.toByte(lenY) * config.weights.insert
  } else if (lenY == 0) {
    Integer.toByte(lenX) * config.weights.delete
  } else do {
    table = pipe(
      Integer.toByte,
      Math.add(1_b),
      List.range(0_b),
      map(
        (x) => pipe(
          Integer.toByte,
          Math.add(1_b),
          List.range(0_b),
          map((y) => x == 0 ? y : y == 0 ? x : x),
          ByteArray.fromList,
        )(lenY),
      ),
    )(lenX)
    i = 1
    j = 1
    IO.pTrace("HOH", table)

    while(i <= lenX) do {
      while(j <= lenY) do {
        IO.pTrace("(" ++ show(i) ++ ", " ++ show(j) ++ ")", table)
        _prevA = String.charAt(i - 1, a)
        _prevB = String.charAt(j - 1, b)
        _subCost = _prevA == _prevB ? 0 : config.weights.substitute
        prevRow = List.nth(i - 1, table)
        at = (x) => map(ByteArray.unsafeAt(x))
        delCost = pipe(
          at(j),
          map(Math.add(config.weights.substitute)),
        )(prevRow)
        insCost = pipe(
          List.nth(i),
          at(j - 1),
          map(Math.add(config.weights.insert)),
        )(table)
        subCost = pipe(
          at(j - 1),
          map(Math.add(_subCost)),
        )(prevRow)
        least = List.reduce(
          (prev, curr) => where(#[prev, curr]) {
            #[Just(t), Just(u)] =>
              Just(t < u ? t : u)

            #[Just(t), Nothing] =>
              Just(t)

            #[Nothing, Just(u)] =>
              Just(u)

            _ =>
              Nothing
          },
          Nothing,
          [delCost, insCost, subCost],
        )
        // IO.pTrace("(" ++ show(i) ++ ", " ++ show(j) ++ ")", { least: fromMaybe(0_b, least) })
        pipe(
          List.nth(i),
          map(
            (row) => do {
              ByteArray.unsafeSet(j, fromMaybe(0_b, least), row)
              setRow = List.set(i, row, table)
              // table := setRow
            },
          ),
        )(table)
        j := j + 1
      }
      i := i + 1
      j := 0
    }
    /* 
            ======= FINAL =======
            0|1|2|3|4|5
            1|1|2|3|4|5
            2|2|2|3|4|5
            3|3|2|3|4|5
            4|4|3|2|3|4
            5|5|4|3|2|3
            6|6|5|4|3|2
            */

    IO.pTrace("TABULAR", table)
    // }
    return pipe(
      List.nth(lenX),
      map(ByteArray.unsafeAt(lenY)),
      fromMaybe(0_b),
    )(table)
  }
}
/*
// List.nth(lenA),
// chain(List.nth(lenB)),
*/

export distance = distanceWithConfig(DEFAULT_CONFIG)
