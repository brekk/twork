import type { Maybe } from "Maybe"

import Array from "Array"
import ByteArray from "ByteArray"
import Float from "Float"
import { always } from "Function"
import IO from "IO"
import Integer from "Integer"
import List from "List"
import Math from "Math"
import { Just, Nothing, fromMaybe } from "Maybe"
import String from "String"

import { log } from "@/Log"



alias DistanceConfig = {
  useDamerau :: Boolean,
  weights :: { delete :: Byte, insert :: Byte, substitute :: Byte },
}

DEFAULT_CONFIG = { useDamerau: true, weights: { delete: 1_b, insert: 1_b, substitute: 1_b } }


// distanceWithConfig :: DistanceConfig -> String -> String -> List (List (Maybe Float))
export distanceWithConfig = (config, a, b) => {
  lenX = String.length(a)
  lenY = String.length(b)
  return if (lenX == 0) {
    Integer.toByte(lenY) * config.weights.insert
  } else if (lenY == 0) {
    Integer.toByte(lenX) * config.weights.delete
  } else do {
    table = pipe(
      Integer.toByte,
      Math.add(1_b),
      List.range(0_b),
      map(
        (x) => pipe(
          Integer.toByte,
          Math.add(1_b),
          List.range(0_b),
          map((y) => x == 0 ? y : y == 0 ? x : x),
          ByteArray.fromList,
        )(lenY),
      ),
      Array.fromList,
    )(lenX)
    i = 1
    j = 1
    IO.pTrace("HOH", table)

    while(i <= lenX) do {
      while(j <= lenY) do {
        IO.pTrace("(" ++ show(i) ++ ", " ++ show(j) ++ ")", table)
        _prevA = String.charAt(i - 1, a)
        _prevB = String.charAt(j - 1, b)
        _subCost = _prevA == _prevB ? 0 : config.weights.substitute
        prevRow = Array.unsafeAt(i - 1, table)
        at = ByteArray.unsafeAt
        delCost = pipe(
          at(j),
          Math.add(config.weights.substitute),
        )(prevRow)
        insCost = pipe(
          Array.unsafeAt(i),
          at(j - 1),
          Math.add(config.weights.insert),
        )(table)
        subCost = pipe(
          at(j - 1),
          Math.add(_subCost),
        )(prevRow)
        least = (
          delCost < insCost
            ? (delCost < subCost ? delCost : subCost)
            : subCost < insCost ? subCost : insCost
        )
        pipe(
          Array.unsafeAt(i),
          (row) => do {
            ByteArray.unsafeSet(j, least, row)
            Array.unsafeSet(i, row, table)
          },
        )(table)
        j := j + 1
      }
      i := i + 1
      j := 1
    }
    IO.pTrace("TABULAR", table)
    // }
    return pipe(
      Array.unsafeAt(lenX),
      ByteArray.unsafeAt(lenY),
    )(table)
  }
}

export distance = distanceWithConfig(DEFAULT_CONFIG)
